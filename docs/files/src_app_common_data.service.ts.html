<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src/app/common/data.service.ts</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AddCarButtonComponent.html">AddCarButtonComponent</a></li>
                                <li><a href="../classes/AddCarComponent.html">AddCarComponent</a></li>
                                <li><a href="../classes/AddFillUpComponent.html">AddFillUpComponent</a></li>
                                <li><a href="../classes/AddReminderComponent.html">AddReminderComponent</a></li>
                                <li><a href="../classes/AppComponent.html">AppComponent</a></li>
                                <li><a href="../classes/AuthModule.html">AuthModule</a></li>
                                <li><a href="../classes/AuthService.html">AuthService</a></li>
                                <li><a href="../classes/CarComponent.html">CarComponent</a></li>
                                <li><a href="../classes/CarDetailViewComponent.html">CarDetailViewComponent</a></li>
                                <li><a href="../classes/CarsComponent.html">CarsComponent</a></li>
                                <li><a href="../classes/CarsDataResolve.html">CarsDataResolve</a></li>
                                <li><a href="../classes/CarsListComponent.html">CarsListComponent</a></li>
                                <li><a href="../classes/ChromeComponent.html">ChromeComponent</a></li>
                                <li><a href="../classes/CompleteRegistrationComponent.html">CompleteRegistrationComponent</a></li>
                                <li><a href="../classes/DataService.html">DataService</a></li>
                                <li><a href="../classes/EditCarComponent.html">EditCarComponent</a></li>
                                <li><a href="../classes/EditFillUpComponent.html">EditFillUpComponent</a></li>
                                <li><a href="../classes/EditReminderComponent.html">EditReminderComponent</a></li>
                                <li><a href="../classes/FillUpDetailComponent.html">FillUpDetailComponent</a></li>
                                <li><a href="../classes/FillUpsComponent.html">FillUpsComponent</a></li>
                                <li><a href="../classes/FillUpsDataResolve.html">FillUpsDataResolve</a></li>
                                <li><a href="../classes/FillUpsListComponent.html">FillUpsListComponent</a></li>
                                <li><a href="../classes/FillUpsListEntryComponent.html">FillUpsListEntryComponent</a></li>
                                <li><a href="../classes/NotificationHubService.html">NotificationHubService</a></li>
                                <li><a href="../classes/ProfileComponent.html">ProfileComponent</a></li>
                                <li><a href="../classes/RemindersComponent.html">RemindersComponent</a></li>
                                <li><a href="../classes/RemindersListComponent.html">RemindersListComponent</a></li>
                                <li><a href="../classes/RemindersListEntryComponent.html">RemindersListEntryComponent</a></li>
                                <li><a href="../classes/SignInComponent.html">SignInComponent</a></li>
                                <li><a href="../classes/SignUpComponent.html">SignUpComponent</a></li>
                                <li><a href="../classes/StatusBarComponent.html">StatusBarComponent</a></li>
                                <li><a href="../classes/SummaryComponent.html">SummaryComponent</a></li>
                                <li><a href="../classes/UtilitiesService.html">UtilitiesService</a></li>
                                <li><a href="../classes/WellcomeComponent.html">WellcomeComponent</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src/app/common/data.service.ts</h1>

<div class="file">
    <pre class="code prettyprint linenums">
import { Injectable } from &#x27;@angular/core&#x27;;
import { Headers, Http } from &#x27;@angular/http&#x27;;

import &#x27;rxjs/add/operator/toPromise&#x27;;

import { Car } from &#x27;./car&#x27;;
import { FillUp } from &#x27;./fillUp&#x27;;
import { Reminder } from &#x27;./reminder&#x27;
import { User } from &#x27;./user&#x27;;

/**
* Provides exchange of data with a back-end database
* via the HTTP server. Three collections are implemented:
* cars, fillups and reminders, with CRUD methods for each.
* Caching is implemented for all the collections.
* A single method handles eventual errors.
*
* @class DataService
**/
@Injectable()
export class DataService {
	private headers = new Headers({&#x27;Content-Type&#x27;: &#x27;application/json&#x27;});
	// URLs to web api
	private carsUrl = &#x27;http://localhost:3000/api/cars&#x27;;  
	private fillUpsUrl = &#x27;http://localhost:3000/api/fillUps&#x27;;
	private remindersUrl = &#x27;http://localhost:3000/api/reminders&#x27;;
	private usersUrl = &#x27;http://localhost:3000/api/user&#x27;;

	private carsCache = {
		data: null,
		dirty: true
	}
	private fillUpsCache: any[] = [];
	private remindersCache: any[] = [];

	clearCache(): void {
		for (let fillUpCache of this.fillUpsCache) {
			fillUpCache.dirty = true;
		}
		for (let reminderCache of this.remindersCache) {
			reminderCache.dirty = true;
		}
		this.carsCache.dirty = true;
	}

  constructor(private http: Http) { }

  getUser(): Promise&lt;User&gt; {
  	return this.http.get(this.usersUrl)
  	             .toPromise()		// Because Angular http service returns observable
  	             .then(response =&gt; {
  	             		return response.json().data as User; // in memory web api returns the data contained
  	             })																									// in data object, for security reasons:
  	             // https://www.owasp.org/index.php/OWASP_AJAX_Security_Guidelines#Always_return_JSON_with_an_Object_on_the_outside
  							 .catch(this.handleError);	// a single method deals with error in this class
  }
  /**
	* This method accepts an User parameter
	* and uses http to PUT an User object to update the server-side database.
	* It returns server response as a Promise, or rejects as an error message
	* or an error object if error message doesn&#x27;t exist
	*
	* @method updateUser
	* @param updatedUser User object to update
	* @return {Promise} Server response
	*/
	updateUser(updatedUser: User): Promise&lt;any&gt; {
	  return this.http
	    .put(this.usersUrl + &#x27;/update&#x27;, JSON.stringify(updatedUser), {headers: this.headers})
	    .toPromise()
	    .then(response =&gt; response)
	    .catch(this.handleError);
	}
  /**
  * This method accepts no parameters and uses http to GET
  * all the Cars of a user from the server. It returns a Promise resolved
  * as an array of Cars, or rejected as an error message or
  * an error object if error message doesn&#x27;t exist
  *
  * @method getCars
  * @return {Promise&lt;Car[]&gt;} The array of Cars as a Promise
  */
  getCars(): Promise&lt;Car[]&gt; {
 		if (!this.carsCache.dirty) {
 			return Promise.resolve(this.carsCache.data);
 		}
 		else
 			return this.http.get(this.carsUrl)
  	             .toPromise()		// Because Angular http service returns observable
  	             .then(response =&gt; {
  	             		this.carsCache.data = response.json().data as Car[];
  	             		this.carsCache.dirty = false;
  	             		return response.json().data as Car[]; // in memory web api returns the data contained
  	             })																									// in data object, for security reasons:
  	             // https://www.owasp.org/index.php/OWASP_AJAX_Security_Guidelines#Always_return_JSON_with_an_Object_on_the_outside
  							 .catch(this.handleError);	// a single method deals with error in this class
  } 
	/**
	* This method accepts a single integer parameter, an id for a Car,
	* and uses it to http GET the corresponding Car data.
	* It returns a Promise resolved as a Car object,
	* or rejected as an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method getCarById
	* @return {Promise&lt;Car&gt;} Car object as a Promise
	*/
	getCarById(id: string): Promise&lt;Car&gt; {
		if (!this.carsCache.dirty) {
 			let cars = this.carsCache.data;
 			for (let car of cars) {
 				if (car.id === id)
 					return Promise.resolve(car);
 			}
 			return Promise.resolve(null);
 		}
 		else 
			return this.http.get(this.carsUrl + &#x27;/&#x27; + id)
	 	             .toPromise()
	 	             .then(response =&gt; {
	 	             		return response.json().data as Car;
	 	             	})
	 	             .catch(this.handleError);
	}
	/**
	* This method accepts a Car parameter and base64 encoded image
	* and uses http to POST new  Car to the server-side database.
	* It returns a Promise resolved as a Car object,
	* or rejected as an error message or
	* an error object if error message doesn&#x27;t exist
	*
	* @method addCar
	* @param newCar a Car to add
	* @param base64Image car avatar
	* @return {Promise&lt;Car&gt;} Added Car as a Promise
	*/
	addCar(newCar: any, base64Image: string): Promise&lt;Car&gt; {
		newCar.base64Image = base64Image;

		return this.http
			.post(this.carsUrl, JSON.stringify(newCar), {headers: this.headers})
			.toPromise()
			.then(response =&gt; {
				this.carsCache.dirty = true;
				return response.json().data as Car
			})
			.catch(this.handleError);
	}

	/**
	* This method accepts a Car parameter and base64 encoded image
	* and uses http to PUT a Car object to update the server-side database.
	* It returns server response as a Promise, or rejects as an error message
	* or an error object if error message doesn&#x27;t exist
	*
	* @method updateCar
	* @param updatedCar Car object to update
	* @param base64Image car avatar
	* @return {Promise} Server response
	*/
	updateCar(updatedCar: any, base64Image: string): Promise&lt;any&gt; {
		updatedCar.base64Image = base64Image;
	  
	  return this.http
	    .put(this.carsUrl, JSON.stringify(updatedCar), {headers: this.headers})
	    .toPromise()
	    .then(response =&gt; {
	    	this.carsCache.dirty = true;
	    	return response;
	    })
	    .catch(this.handleError);
	}

	/**
	* This method accepts a parameter of number type and uses http to DELETE Car 
	* of this id from the server-side database. It returns a Promise resolved
	* as server response object, or rejected as an error message or
	* an error object if error message doesn&#x27;t exist
	*
	* @method deleteCar
	* @param carId Car.id of the Car object to delete
	* @return {Promise&lt;any&gt;} Server response as a promise
	*/
	deleteCar(id: string): Promise&lt;any&gt; {
		const url = &#x60;${this.carsUrl}/${id}&#x60;;

		return this.http
			.delete(url)
			.toPromise()
			.then(response =&gt; {
	    	this.carsCache.dirty = true;
	    	return response;
	    })
			.catch(this.handleError);
	}

	/**
	* This method accepts car id as a parameter and uses http
	* to GET all the Fillups for a Car. It returns a Promise
	* resolved as an array of FillUps,
	* or rejected as an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method getFillUps
	* @return {Promise&lt;FillUp[]&gt;}
	*/
	getFillUps(carId: string): Promise&lt;FillUp[]&gt; {
		if (this.fillUpsCache[carId] &amp;&amp; !this.fillUpsCache[carId].dirty) {
		 	return Promise.resolve(this.fillUpsCache[carId].data);
		}
		else 
		  return this.http.get(this.fillUpsUrl + &#x27;/&#x27; + carId)
	 	             .toPromise()
	 	             .then(response =&gt; {
	 	             		this.fillUpsCache[carId] = {};
	 	             		this.fillUpsCache[carId].data = response.json().data as FillUp[];
	 	             		this.fillUpsCache[carId].dirty = false;
	 	             		return response.json().data as FillUp[];
	 	             	})
	 	             .catch(this.handleError);
	}
  /**
	* This method accepts two parameters, an id for a Fill Up,
	* and an id for a car. It uses http GET to fetch the corresponding
	* Fillup for a Car.
	* It returns a Promise resolved as a FillUp object,
	* or rejected as an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method getFillUpById
	* @param carId id of a Car to which a fill up belongs to
	* @param id id of a fill up
	* @return {Promise&lt;FillUp&gt;} The FillUp for a Car as a Promise
	*/
	getFillUpById(carId: string, id: string): Promise&lt;FillUp&gt; {
		if (this.fillUpsCache[carId] &amp;&amp; !this.fillUpsCache[carId].dirty) {
 			let fillUps = this.fillUpsCache[carId].data;
     		for (let fillUp of fillUps) {
     			if (fillUp.id === id)
     				return Promise.resolve(fillUp);
     		}
     		return Promise.resolve(null);
 		}
 		else
			return this.http.get(this.fillUpsUrl + &#x27;/one/&#x27; + id)
	 	             .toPromise()
	 	             .then(response =&gt; {
	 	             		return response.json().data as FillUp;
	 	             	})
	 	             .catch(this.handleError);
	}
  /**
	* This method accepts no parameters and returns an object containing
	* arrays of all fill ups for all the cars. Object keys are car ids, and
	* values are arrays of Fill Ups. Method returns a Promise 
	* which on error is rejected as an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method getAllFillUps
	* @return {Promise&lt;Object&gt;}
	*/
	getAllFillUps(): Promise&lt;Object&gt; {
		let allFillUps: Object = {};

		return this.getCars().then(cars =&gt; {
			let promises: Promise&lt;Object&gt;[] = [];
			for (let car of cars) {
				promises.push(this.getFillUps(car.id));
			}
			return Promise.all(promises).then(fillUps =&gt; {
				for (let i = 0; i &lt; fillUps.length; ++i) {
					allFillUps[cars[i].id] = fillUps[i];
				}
				return allFillUps;
			}, err =&gt; {
				this.handleError(err);
			});
		})
		.catch(this.handleError);
	}
	/**
	* This method accepts a car id and a FillUp object as a parameter and uses
	* http POST to add a fill up to a Car. It returns a Promise resolved
	* to a FillUp object, or rejected as an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method addFillUp
	* @param carId Id of the car to which the new fill up is to be added
	* @param newFillUp The Fillup to be added
	* @return {Promise&lt;FillUp&gt;} The FillUp added as a Promise
	*/
	addFillUp(carId: string, newFillUp: FillUp): Promise&lt;FillUp&gt; {
		return this.http
			.post(this.fillUpsUrl + &#x27;/&#x27; + carId, JSON.stringify(newFillUp), {headers: this.headers})
			.toPromise()
			.then(response =&gt; {
				this.fillUpsCache[carId].dirty = true;
				return response.json().data as FillUp;
			})
			.catch(this.handleError);
	}
	/**
	* This method accepts car Id and a FillUp object as parameters
	* and uses http to PUT updated FillUp to the database.
	* It returns server response as a Promise on success,
	* or rejected as an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method updateFillUp
	* @param updatedFillUp The Fillup to be updated
	* @return {Promise&lt;any&gt;} The server response, as a Promise
	*/
	updateFillUp(carId: string, updatedFillUp: FillUp): Promise&lt;any&gt; {
		return this.http
						.put(&#x60;${this.fillUpsUrl}&#x60;, JSON.stringify(updatedFillUp), {headers: this.headers})
						.toPromise()
						.then(response =&gt; {
							this.fillUpsCache[carId].dirty = true;
							return response;
						})
						.catch(this.handleError);
	}
	/**
	* This method accepts car.id and FillUp.id as parameters and deletes the corresponding
	* entry in the database using http DELETE. It returns server response as a Promise
	* on success, and rejects with an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method deleteFillUp
	* @param carId id of the car to which fill up belongs to
	* @param fillUpId	id of the FillUp to be deleted
	* @return {Promise&lt;FillUp&gt;}	The deleted FillUp
	*/
	deleteFillUp(carId: string, fillUpId: string): Promise&lt;any&gt; {
		return this.http
						.delete(&#x60;${this.fillUpsUrl}/${carId}/${fillUpId}&#x60;)
						.toPromise()
						.then(response =&gt; {
							this.fillUpsCache[carId].dirty = true;
							return response;
						})
						.catch(this.handleError);
	}
	/**
	* This method accepts car id as a parameter and returns all reminders
	* of a car by issuing a http GET request. It returns an array
	* of Reminder objects as a Promise. On error it rejects
	* with an error message, or an error object if error message doesn&#x27;t exist
	*
	* @method getReminders
	* @return {Promise&lt;Reminder[]&gt;}	All the reminders of a car as a Promise
	*/
	getReminders(carId: string): Promise&lt;Reminder[]&gt; {
		if (this.remindersCache[carId] &amp;&amp; !this.remindersCache[carId].dirty) {
		 	return Promise.resolve(this.remindersCache[carId].data);
		}
		return this.http.get(this.remindersUrl + &#x27;/&#x27; + carId)
									.toPromise()
									.then(response =&gt; {
	 	             		this.remindersCache[carId] = {};
	 	             		this.remindersCache[carId].data = response.json().data as Reminder[];
	 	             		this.remindersCache[carId].dirty = false;
	 	             		return response.json().data as Reminder[];
	 	             	})
									.catch(this.handleError);
	}
	/**
	* This method accepts two parameters, an id for a Reminder,
	* and an id for a car. It uses http GET to fetch the corresponding
	* Reminder for a Car.
	* It returns a Promise resolved as a Reminder object,
	* or rejected as an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method getReminderById
	* @return {Promise&lt;Reminder&gt;} The Reminder for a Car as a Promise
	*/
	getReminderById(carId: string, id: string): Promise&lt;Reminder&gt; {
		if (this.remindersCache[carId] &amp;&amp; !this.remindersCache[carId].dirty) {
 			let reminders = this.remindersCache[carId].data;
     		for (let reminder of reminders) {
     			if (reminder.id === id)
     				return Promise.resolve(reminder);
     		}
     		return Promise.resolve(null);
 		}
 		else
			return this.http.get(this.remindersUrl + &#x27;/one/&#x27; + id)
	 	             .toPromise()
	 	             .then(response =&gt; {
	 	             		return response.json().data as Reminder;
	 	             	})
	 	             .catch(this.handleError);
	}
	/**
	* This method accepts no parameters and returns an object containing
	* arrays of all reminders for all the cars. Object keys are car ids, and
	* values are arrays of Reminders. Method returns a Promise 
	* which on error is rejected as an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method getAllReminders
	* @return {Promise&lt;Object&gt;}
	*/
	getAllReminders(): Promise&lt;Object&gt; {
		let allReminders: Object = {};

		return this.getCars().then(cars =&gt; {
			let promises: Promise&lt;Object&gt;[] = [];
			for (let car of cars) {
				promises.push(this.getReminders(car.id));
			}
			return Promise.all(promises).then(reminders =&gt; {
				for (let i = 0; i &lt; reminders.length; ++i) {
					allReminders[cars[i].id] = reminders[i];
				}
				return allReminders;
			}, err =&gt; {
				this.handleError(err);
			});
		})
		.catch(this.handleError);
	}
	/**
	* This method accepts a parameter of Reminder type and calls http to POST this new Reminder
	* to a database. It returns a Promise resolved as the added Reminder on success, and on
	* error it returns error message or an error object if error message doesn&#x27;t exist
	*
	* @method addReminder
	* @param newReminder Reminder to be added
	* @return Promise&lt;Reminder&gt; The added Reminder
	*/
	addReminder(carId: string, newReminder: Reminder): Promise&lt;Reminder&gt; {
		return this.http
			.post(this.remindersUrl + &#x27;/&#x27; + carId, JSON.stringify(newReminder), {headers: this.headers})
			.toPromise()
			.then(response =&gt; {
				this.remindersCache[carId].dirty = true;
				return response.json().data as Reminder;
			})
			.catch(this.handleError);
	}
	/**
	* This method accepts car Id and a Reminder object as parameters
	* and uses http to PUT updated Reminder to the database.
	* It returns server response as a Promise on success,
	* or rejected as an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method updateReminder
	* @param updatedReminder The Reminder to be updated
	* @return {Promise&lt;any&gt;} The server response, as a Promise
	*/
	updateReminder(carId: string, updatedReminder: Reminder): Promise&lt;any&gt; {
		return this.http
						.put(&#x60;${this.remindersUrl}&#x60;, JSON.stringify(updatedReminder), {headers: this.headers})
						.toPromise()
						.then(response =&gt; {
							this.remindersCache[carId].dirty = true;
							return response;
						})
						.catch(this.handleError);
	}
	/**
	* This method accepts Reminder.id as a parameter and deletes the corresponding entry
	* in the database using http DELETE. It returns server response as a Promise 
	* on success, and rejects with an error message or an error object
	* if error message doesn&#x27;t exist
	*
	* @method deleteReminder
	* @param reminderId	id of the Reminder to be deleted
	* @return {Promise&lt;Reminder&gt;}	The deleted Reminder
	*/
	deleteReminder(carId: string, reminderId: string): Promise&lt;any&gt; {
		return this.http
						.delete(&#x60;${this.remindersUrl}/${carId}/${reminderId}&#x60;)
						.toPromise()
						.then(response =&gt; {
							this.remindersCache[carId].dirty = true;
							return response;
						})
						.catch(this.handleError);
	}



	private handleError(error: any): Promise&lt;any&gt; {
    console.error(&#x27;An error occurred&#x27;, error); // for dev purposes only; TODO: delete for prod
    return Promise.reject(error.message || error.statusText || error);
  }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
